name: .NET CI Pipeline with SonarQube Analysis

on:
  push:
    branches:
      - main  # Trigger on push to the main branch
  pull_request:
    branches:
      - main  # Trigger on pull request to the main branch
  workflow_dispatch:  # Manual trigger of the workflow

jobs:
  sonarcloud_analysis:
    runs-on: self-hosted  # Use self-hosted runner
      
    steps:
      # Checkout the CI pipeline repository (this repository where the action lives)
      - name: Checkout CI pipeline repository
        uses: actions/checkout@v2

      # Checkout the code repository (the other repository you need to build)
      - name: Checkout code from another repository
        uses: actions/checkout@v2
        with:
          repository: krishnakekan09/dotnet_hello_World  # The repository to check out
          token: ${{ secrets.GITHUB_TOKEN }}  # GitHub token for authentication
          path: code-repo  # Optional: Specify where to store the repo on the runner

      # Install dependencies (if required)
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip curl

      # Set up .NET SDK
      - name: Set up .NET SDK
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '7.0'

      # Cache SonarQube packages
      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      # Cache SonarQube scanner
      - name: Cache SonarQube scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner

      # Install SonarQube scanner if not cached
      - name: Install SonarQube scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        run: |
          mkdir -p ./.sonar/scanner
          dotnet tool update dotnet-sonarscanner --tool-path ./.sonar/scanner

      # Run SonarQube analysis
      - name: Build and analyze
        run: |
          # Begin SonarQube analysis
          ./.sonar/scanner/dotnet-sonarscanner begin /k:"${{ secrets.DOTNET_HELLO_WORLD_PROJECTKEY }}" /d:sonar.token="${{ secrets.SONAR_TOKEN }}" /d:sonar.host.url="http://localhost:9000"
          # Build the project
          dotnet build
          # End SonarQube analysis
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

      # Build Docker image
      - name: Build Docker image
        run: |
          cd code-repo  # Navigate to the folder containing the Dockerfile
          docker build -t hello-world-api:${{ github.sha }} .

      # Run tests inside Docker container
      - name: Run tests inside Docker container
        run: |
          cd code-repo  # Navigate to the folder containing the Dockerfile
          docker run --rm hello-world-api:${{ github.sha }} dotnet test  # Run tests inside the container

      # Docker image scanning (optional)
      - name: Scan Docker image with Trivy
        run: |
          trivy image --exit-code 1 --severity HIGH,CRITICAL hello-world-api:${{ github.sha }}  # Fail if vulnerabilities are found

      # Push Docker image to registry
      - name: Push Docker image
        run: |
          docker push hello-world-api:${{ github.sha }}

  deploy:
    runs-on: self-hosted  # Use self-hosted runner for deployment as well
    needs: sonarcloud_analysis  # Ensure SonarCloud analysis finishes before deploying

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Deploy Docker image to production
      - name: Deploy Docker image
        run: |
          ssh user@your-server "docker pull hello-world-api:${{ github.sha }}"
          ssh user@your-server "docker stop hello-world-api || true && docker run -d -p 5000:5000 --name hello-world-api hello-world-api:${{ github.sha }}"

  failure-notify:
    runs-on: self-hosted  # Use self-hosted runner for failure notification as well
    if: failure()  # Runs only if any of the jobs fail

    steps:
      - name: Notify failure (via email or Slack)
        run: |
          curl -X POST -H 'Content-type: application/json' --data '{"text":"Build or Deployment Failed!"}' https://hooks.slack.com/services/your/slack/webhook
